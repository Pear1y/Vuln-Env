/*
* ClassLoader.defineClass() 方法运行后，并不会执行 static block
* 而 Class.newInstance() 会执行，这两个地方会涉及到 Jdk7u21 payload 恶意代码的具体执行点
*
* 关于 Class.forName("SomeClass"); 和 ClassLoader.loadClass("SomeClass");
* 有兴趣的可以参考 https://stackoverflow.com/a/8100407/6467552
* */

package com.example.demo.model;

import javassist.ClassPool;
import javassist.CtClass;
import org.junit.Assert;
import org.junit.Test;

import java.lang.reflect.Method;

public class StaticInitializerCheckRunTest {

    @Test  // Class.newInstance() 方式
    public void testStaticBlock() throws Exception {
        // 内部调用 loadClass(name, false) 不会 initialize class，无 print
        StaticInitializerTest.class.getClassLoader().loadClass(StaticInitializerTest.class.getName());
        // 反射加载，会 initialize class，print static initializer
        Class.forName("com.example.demo.model.StaticInitializerTest");
        // 实例化，先打印 static initializer，再打印 constructor executed
        Assert.assertNotNull(StaticInitializerTest.class.newInstance());
        // 实例化，先打印 static initializer，再打印 constructor executed
        Assert.assertNotNull(new StaticInitializerTest());
    }

    @Test  // ClassLoader.defineClass() 方式
    public void testDefineClass() throws Exception {
        ClassPool pool = ClassPool.getDefault();
        CtClass cc = pool.get(StaticInitializerTest.class.getName());
        // avoid duplicate class definition
        String randomClassName = "EvilCat" + System.nanoTime();
        cc.setName(randomClassName);
        byte[] byteCodes = cc.toBytecode();
        // protected method, use reflect
        Method method = ClassLoader.class.getDeclaredMethod("defineClass", String.class, byte[].class, int.class, int.class);
        method.setAccessible(true);
        // 不会 initialize class，无 print
        method.invoke(StaticInitializerTest.class.getClassLoader(), new Object[]{(String) null, byteCodes, 0, byteCodes.length});
    }
}
